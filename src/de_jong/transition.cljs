(ns de-jong.transition
  (:require [de-jong.points-calculator :refer [in-range]]))

(def tau (* 2 js/Math.PI))

(defn sign [x]
  (cond
    (> x 0) 1
    (< x 0) -1
    (= x 0) 0))

(defn displacement-vector
  "Finds the displacement vector between two position vectors in a torus
  generated by the product of n unit-circles"
  [initial final]
  {:pre [(every? in-range (concat initial final))]}
  (let [f (fn [q-i p-i]
            (let [in-plane    (- q-i p-i)
                  wrap-around (* (- tau (js/Math.abs in-plane)) (- (sign in-plane)))]
              (if (<= (js/Math.abs in-plane) (js/Math.abs wrap-around))
                in-plane
                wrap-around)))]
    (vec (map f final initial))))

(defn lerp [t initial final]
  {:pre [(and (>= t 0) (<= t 1))]}
  (+ initial (* t (- final initial))))

(defn lerp-vectors [num-frames initial final]
  (let [step     (/ 1 num-frames)
        vec-lerp (fn [t i f] (map (partial lerp t) i f))]
    (map #(vec-lerp % initial final) (range 0 1 step))))

(defn wrap-around
  "Wraps values from [-2 * PI, 2 * PI) into [-PI, PI)"
  [x]
  (cond
    (>= x js/Math.PI) (- x tau)
    (< x (- js/Math.PI)) (+ x tau)
    :else x))

(defn lerp-vectors-torus [num-frames initial final]
  (let [displacement    (displacement-vector initial final)
        effective-final (map + initial displacement)
        normalize       (partial map wrap-around)]
    (map normalize (lerp-vectors num-frames initial effective-final))))

(defn transition-params
  "For a sequence of de jong parameters
  ((a_0 b_0 c_0 d_0) (a_1 b_1 c_1 d_1) (a_2 b_2 c_2 d_2) ...), and a number of
  frames, returns another sequence of de jong paramters with num-frames frames
  interposed
  ((a_0 b_0 c_0 d_0) {num-frames more frames} (a_1 b_1 c_1 d_1)
  {num-frame more frames} (a_2 b_2 c_2 d_2) ...)"
  [num-frames xs]
  (let [pairs (partition 2 1 xs)]
    (mapcat (fn [[a b]] (lerp-vectors-torus num-frames a b)) pairs)))
