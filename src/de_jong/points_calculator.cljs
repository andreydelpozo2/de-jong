(ns de-jong.points-calculator)

(def points-to-draw (js/Math.pow 2 13))

(defn in-range [x]
  (and (>= x (- js/Math.PI)) (<= x js/Math.PI)))

(defn de-jong-ifs [a b c d]
  {:pre [(every? in-range [a b c d])]}
  (fn [x y z]
    [(- (js/Math.sin (* a y)) (js/Math.cos (* b x)))
     (- (js/Math.sin (* c x)) (js/Math.cos (* d y)))
     (- (js/Math.sin (* 2.0 x)) (js/Math.cos (* 2.0 y)))]))

(defn- vertex-array [length]
  (js/Float32Array. (* 3 length)))

(defn random-vals [minimum maximum]
  (repeatedly #(+ (rand (- maximum minimum)) minimum)))

(defn- write-random-values! [minimum maximum vertices]
  (let [length (.-length vertices)]
    (loop [i      0
           values (random-vals minimum maximum)]
      (if (< i length)
        (do
          (aset vertices i (first values))
          (recur (inc i) (rest values)))))
    vertices))

(defn random-vertex-array [length minimum maximum]
  (let [arr (vertex-array length)]
    (write-random-values! minimum maximum arr)))

(defn- get-vertices [vertices]
  (partition 3 (array-seq vertices)))

(defn vertices-apply [f vertices]
  (let [length  (.-length vertices)
        new-arr (vertex-array (/ length 3))]
    (loop [i      0
           values (get-vertices vertices)]
      (if (< i length)
        (let [[x y z] (first values)
              [x2 y2 z2] (f x y z)]
          (aset new-arr i x2)
          (aset new-arr (+ i 1) y2)
          (aset new-arr (+ i 2) z2)
          (recur (+ i 3) (rest values)))))
    new-arr))

; TEAM TAU!!!1!
(def tau (* 2 js/Math.PI))

(defn sign [x]
  (cond
    (> x 0) 1
    (< x 0) -1
    (= x 0) 0))

(defn displacement-vector
  "Finds the displacement vector between two position vectors in a
  n-dimentional torus generated by the product of n unit-circles"
  [initial final]
  {:pre [(every? in-range (concat initial final))]}
  (let [f (fn [q-i p-i]
            (let [in-plane    (- q-i p-i)
                  wrap-around (* (- tau (js/Math.abs in-plane)) (- (sign in-plane)))]
              (if (<= (js/Math.abs in-plane) (js/Math.abs wrap-around))
                in-plane
                wrap-around)))]
    (vec (map f final initial))))
